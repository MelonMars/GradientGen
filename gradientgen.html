<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gradient Gen</title>
<style>
  html, body { margin: 0; height: 100%; background: black; overflow: hidden; font-family: Arial, sans-serif; }
  canvas { display: block; }
  #minimap {
    position: absolute;
    bottom: 10px;
    right: 10px;
    border: 1px solid white;
    cursor: pointer;
    background: rgba(0,0,0,0.5);
  }
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.9);
    padding: 15px;
    border-radius: 8px;
    color: white;
    min-width: 280px;
    font-size: 12px;
    max-height: 90vh;
    overflow-y: auto;
  }
  .control-group {
    margin-bottom: 15px;
    border-bottom: 1px solid #333;
    padding-bottom: 10px;
  }
  .control-group:last-child {
    border-bottom: none;
  }
  .control-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #fff;
  }
  .control-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
  }
  input[type="range"] {
    flex: 1;
    min-width: 100px;
  }
  input[type="color"] {
    width: 35px;
    height: 25px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  .value-display {
    min-width: 35px;
    font-family: monospace;
    font-size: 11px;
    color: #ccc;
  }
  button {
    background: #333;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
  }
  button:hover {
    background: #555;
  }
  .animate-btn {
    background: #2a5d31;
  }
  .animate-btn.active {
    background: #4a9;
  }
  .add-blob-btn {
    background: #1a4b8c;
  }
  .add-blob-btn:hover {
    background: #2a5b9c;
  }
  .blob-item {
    background: rgba(255,255,255,0.1);
    padding: 10px;
    border-radius: 4px;
    margin-bottom: 8px;
  }
  .blob-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .blob-title {
    font-weight: bold;
    font-size: 11px;
  }
  .remove-blob {
    background: #8b1538;
    padding: 2px 6px;
    font-size: 10px;
  }
  .remove-blob:hover {
    background: #a52850;
  }
  .preset-buttons {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-top: 8px;
  }
  .preset-btn {
    background: #2d4a22;
    font-size: 10px;
    padding: 4px 8px;
  }
  .preset-btn:hover {
    background: #3d5a32;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<canvas id="minimap" width="150" height="150"></canvas>

<div id="controls">
  <div class="control-group">
    <label>Animation</label>
    <div class="control-row">
      <button id="animateBtn" class="animate-btn">Start Animation</button>
    </div>
    <div class="control-row">
      <input type="range" id="animSpeed" min="0" max="2" step="0.1" value="0.5">
      <span class="value-display" id="animSpeedVal">0.5</span>
      <span>Speed</span>
    </div>
  </div>
  
  <div class="control-group">
    <label>Global Effects</label>
    <div class="control-row">
      <input type="range" id="flowStrength" min="0" max="0.3" step="0.01" value="0.1">
      <span class="value-display" id="flowStrengthVal">0.1</span>
      <span>Flow</span>
    </div>
    <div class="control-row">
      <input type="range" id="noiseStrength" min="0" max="0.1" step="0.005" value="0.03">
      <span class="value-display" id="noiseStrengthVal">0.03</span>
      <span>Noise</span>
    </div>
    <div class="control-row">
      <input type="range" id="intensity" min="0.5" max="2.0" step="0.1" value="1.0">
      <span class="value-display" id="intensityVal">1.0</span>
      <span>Intensity</span>
    </div>
  </div>
  
  <div class="control-group">
    <label>Blending</label>
    <div class="control-row">
      <select id="blendMode">
        <option value="0">Smooth Mix</option>
        <option value="1">Additive</option>
        <option value="2">Screen</option>
        <option value="3">Overlay</option>
      </select>
    </div>
  </div>
  
  <div class="control-group">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <label style="margin: 0;">Blobs</label>
      <button id="addBlobBtn" class="add-blob-btn">+ Add Blob</button>
    </div>
    <div class="preset-buttons">
      <button class="preset-btn" onclick="loadPreset('aurora')">Aurora</button>
      <button class="preset-btn" onclick="loadPreset('nebula')">Nebula</button>
      <button class="preset-btn" onclick="loadPreset('sunset')">Sunset</button>
      <button class="preset-btn" onclick="loadPreset('ocean')">Ocean</button>
    </div>
    <div id="blobsList"></div>
  </div>
</div>

<script id="fragShader" type="x-shader/x-fragment">
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;
uniform float u_flowStrength;
uniform float u_noiseStrength;
uniform float u_intensity;
uniform int u_blendMode;
uniform int u_blobCount;

uniform vec2 u_blobPositions[8];
uniform vec3 u_blobColors[8];
uniform float u_blobRadii[8];
uniform float u_blobIntensities[8];
uniform float u_blobPulseStrengths[8];

float hash21(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float smoothNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float a = hash21(i + vec2(0.0, 0.0));
    float b = hash21(i + vec2(1.0, 0.0));
    float c = hash21(i + vec2(0.0, 1.0));
    float d = hash21(i + vec2(1.0, 1.0));
    
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p) {
    float v = 0.0;
    float amp = 0.5;
    float freq = 1.0;
    for(int i = 0; i < 4; i++) {
        v += amp * smoothNoise(p * freq);
        freq *= 2.0;
        amp *= 0.5;
    }
    return v;
}

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    vec2 p = uv;
    
    vec2 flow = vec2(
        fbm(p * 2.0 + vec2(0.0, u_time * 0.3)),
        fbm(p * 2.5 + vec2(u_time * 0.25, 0.0))
    ) - 0.5;
    p += flow * u_flowStrength;
    
    float noise = (smoothNoise(p * 5.0 + u_time * 0.1) - 0.5) * u_noiseStrength;
    p += noise;
    
    vec3 finalColor = vec3(0.0);
    float totalWeight = 0.0;
    
    for(int i = 0; i < 8; i++) {
        if(i >= u_blobCount) break;
        
        vec2 animPos = u_blobPositions[i];
        if(u_blobPulseStrengths[i] > 0.0) {
            float pulsePhase = float(i) * 1.5;
            float pulse = sin(u_time * 1.2 + pulsePhase) * u_blobPulseStrengths[i] * 0.08;
            animPos += vec2(
                sin(u_time * 0.8 + pulsePhase) * pulse,
                cos(u_time * 1.1 + pulsePhase) * pulse
            );
        }
        
        float dist = distance(p, animPos);
        float radius = u_blobRadii[i];
        float intensity = u_blobIntensities[i];
        
        float influence;
        if(i == 0 || i == 3 || i == 6) {
            influence = exp(-dist * dist / (radius * radius)) * intensity;
        } else if(i == 1 || i == 4 || i == 7) {
            influence = smoothstep(radius, 0.0, dist) * intensity;
        } else {
            influence = intensity / (1.0 + dist * dist / (radius * radius));
        }
        
        vec3 blobColor = u_blobColors[i];
        blobColor += sin(u_time * 0.5 + p.x * 3.0 + float(i)) * 0.05;
        
        if(u_blendMode == 0) {
            finalColor += blobColor * influence;
            totalWeight += influence;
        } else if(u_blendMode == 1) {
            finalColor += blobColor * influence;
        } else if(u_blendMode == 2) {
            vec3 screen = 1.0 - (1.0 - finalColor) * (1.0 - blobColor * influence);
            finalColor = screen;
        } else {
            vec3 overlay = mix(
                2.0 * finalColor * blobColor * influence,
                1.0 - 2.0 * (1.0 - finalColor) * (1.0 - blobColor * influence),
                step(0.5, finalColor)
            );
            finalColor = overlay;
        }
    }
    
    if(u_blendMode == 0 && totalWeight > 0.0) {
        finalColor /= totalWeight;
    }
    
    finalColor *= u_intensity;
    
    float vignette = smoothstep(1.4, 0.6, length(uv - 0.5));
    finalColor *= mix(0.8, 1.0, vignette);
    
    finalColor = pow(finalColor, vec3(0.95));
    
    gl_FragColor = vec4(finalColor, 1.0);
}
</script>

<script id="vertShader" type="x-shader/x-vertex">
attribute vec2 position;
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
}
</script>

<script>
const glcanvas = document.getElementById('glcanvas');
const minimap = document.getElementById('minimap');
const gl = glcanvas.getContext('webgl');
glcanvas.width = window.innerWidth;
glcanvas.height = window.innerHeight;

function compileShader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
    }
    return s;
}

const vertShader = compileShader(gl.VERTEX_SHADER, document.getElementById('vertShader').textContent);
const fragShader = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fragShader').textContent);
const prog = gl.createProgram();
gl.attachShader(prog, vertShader);
gl.attachShader(prog, fragShader);
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,  1, -1,  -1, 1,
  -1,  1,  1, -1,   1, 1
]), gl.STATIC_DRAW);
const positionLoc = gl.getAttribLocation(prog, 'position');
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

const uniforms = {
    resolution: gl.getUniformLocation(prog, 'u_resolution'),
    time: gl.getUniformLocation(prog, 'u_time'),
    flowStrength: gl.getUniformLocation(prog, 'u_flowStrength'),
    noiseStrength: gl.getUniformLocation(prog, 'u_noiseStrength'),
    intensity: gl.getUniformLocation(prog, 'u_intensity'),
    blendMode: gl.getUniformLocation(prog, 'u_blendMode'),
    blobCount: gl.getUniformLocation(prog, 'u_blobCount'),
    blobPositions: gl.getUniformLocation(prog, 'u_blobPositions'),
    blobColors: gl.getUniformLocation(prog, 'u_blobColors'),
    blobRadii: gl.getUniformLocation(prog, 'u_blobRadii'),
    blobIntensities: gl.getUniformLocation(prog, 'u_blobIntensities'),
    blobPulseStrengths: gl.getUniformLocation(prog, 'u_blobPulseStrengths')
};

let blobs = [
    { x: 0.3, y: 0.4, color: '#ff3366', radius: 0.35, intensity: 1.0, pulseStrength: 0.3 },
    { x: 0.7, y: 0.6, color: '#3366ff', radius: 0.4, intensity: 0.8, pulseStrength: 0.2 }
];

let nextBlobId = 0;
let isAnimating = false;
let animSpeed = 0.5;
let dragState = { active: false, blobIndex: -1 };

const animateBtn = document.getElementById('animateBtn');
const animSpeedSlider = document.getElementById('animSpeed');
const animSpeedVal = document.getElementById('animSpeedVal');
const flowStrengthSlider = document.getElementById('flowStrength');
const flowStrengthVal = document.getElementById('flowStrengthVal');
const noiseStrengthSlider = document.getElementById('noiseStrength');
const noiseStrengthVal = document.getElementById('noiseStrengthVal');
const intensitySlider = document.getElementById('intensity');
const intensityVal = document.getElementById('intensityVal');
const blendModeSelect = document.getElementById('blendMode');
const addBlobBtn = document.getElementById('addBlobBtn');
const blobsList = document.getElementById('blobsList');

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16) / 255,
        parseInt(result[2], 16) / 255,
        parseInt(result[3], 16) / 255
    ] : [1, 0, 0];
}

function createBlobElement(blob, index) {
    const blobDiv = document.createElement('div');
    blobDiv.className = 'blob-item';
    blobDiv.innerHTML = `
        <div class="blob-header">
            <span class="blob-title">Blob ${index + 1}</span>
            <button class="remove-blob" onclick="removeBlob(${index})">Remove</button>
        </div>
        <div class="control-row">
            <input type="color" id="color_${index}" value="${blob.color}">
            <span style="flex: 1;">Color</span>
        </div>
        <div class="control-row">
            <input type="range" id="radius_${index}" min="0.1" max="0.8" step="0.05" value="${blob.radius}">
            <span class="value-display" id="radiusVal_${index}">${blob.radius}</span>
            <span>Size</span>
        </div>
        <div class="control-row">
            <input type="range" id="intensity_${index}" min="0.1" max="2.0" step="0.1" value="${blob.intensity}">
            <span class="value-display" id="intensityVal_${index}">${blob.intensity}</span>
            <span>Intensity</span>
        </div>
        <div class="control-row">
            <input type="range" id="pulse_${index}" min="0" max="1" step="0.05" value="${blob.pulseStrength}">
            <span class="value-display" id="pulseVal_${index}">${blob.pulseStrength}</span>
            <span>Pulse</span>
        </div>
    `;
    
    const colorInput = blobDiv.querySelector(`#color_${index}`);
    const radiusInput = blobDiv.querySelector(`#radius_${index}`);
    const intensityInput = blobDiv.querySelector(`#intensity_${index}`);
    const pulseInput = blobDiv.querySelector(`#pulse_${index}`);
    
    colorInput.addEventListener('input', () => blob.color = colorInput.value);
    
    radiusInput.addEventListener('input', () => {
        blob.radius = parseFloat(radiusInput.value);
        blobDiv.querySelector(`#radiusVal_${index}`).textContent = blob.radius;
    });
    
    intensityInput.addEventListener('input', () => {
        blob.intensity = parseFloat(intensityInput.value);
        blobDiv.querySelector(`#intensityVal_${index}`).textContent = blob.intensity;
    });
    
    pulseInput.addEventListener('input', () => {
        blob.pulseStrength = parseFloat(pulseInput.value);
        blobDiv.querySelector(`#pulseVal_${index}`).textContent = blob.pulseStrength;
    });
    
    return blobDiv;
}

function updateBlobsList() {
    blobsList.innerHTML = '';
    blobs.forEach((blob, index) => {
        blobsList.appendChild(createBlobElement(blob, index));
    });
}

function addBlob() {
    if (blobs.length >= 8) return; 
    
    const colors = ['#ff6b35', '#f7931e', '#ffd23f', '#06ffa5', '#118ab2', '#073b4c', '#b07bac', '#ff006e'];
    blobs.push({
        x: 0.2 + Math.random() * 0.6,
        y: 0.2 + Math.random() * 0.6,
        color: colors[blobs.length % colors.length],
        radius: 0.2 + Math.random() * 0.3,
        intensity: 0.5 + Math.random() * 0.5,
        pulseStrength: Math.random() * 0.4
    });
    updateBlobsList();
}

function removeBlob(index) {
    if (blobs.length <= 1) return; 
    blobs.splice(index, 1);
    updateBlobsList();
}

const presets = {
    aurora: [
        { x: 0.2, y: 0.3, color: '#00ff88', radius: 0.4, intensity: 1.2, pulseStrength: 0.4 },
        { x: 0.5, y: 0.7, color: '#0088ff', radius: 0.35, intensity: 0.9, pulseStrength: 0.3 },
        { x: 0.8, y: 0.4, color: '#8800ff', radius: 0.3, intensity: 0.7, pulseStrength: 0.5 }
    ],
    nebula: [
        { x: 0.3, y: 0.5, color: '#ff3366', radius: 0.5, intensity: 1.0, pulseStrength: 0.2 },
        { x: 0.6, y: 0.3, color: '#6633ff', radius: 0.4, intensity: 0.8, pulseStrength: 0.3 },
        { x: 0.7, y: 0.7, color: '#ff6633', radius: 0.3, intensity: 0.6, pulseStrength: 0.1 },
        { x: 0.4, y: 0.8, color: '#33ffff', radius: 0.25, intensity: 0.5, pulseStrength: 0.4 }
    ],
    sunset: [
        { x: 0.2, y: 0.6, color: '#ff4500', radius: 0.6, intensity: 1.5, pulseStrength: 0.1 },
        { x: 0.5, y: 0.5, color: '#ff6b35', radius: 0.4, intensity: 1.0, pulseStrength: 0.2 },
        { x: 0.8, y: 0.4, color: '#ffd23f', radius: 0.3, intensity: 0.8, pulseStrength: 0.0 }
    ],
    ocean: [
        { x: 0.3, y: 0.4, color: '#006994', radius: 0.4, intensity: 1.0, pulseStrength: 0.3 },
        { x: 0.7, y: 0.6, color: '#118ab2', radius: 0.35, intensity: 0.9, pulseStrength: 0.4 },
        { x: 0.5, y: 0.8, color: '#06ffa5', radius: 0.2, intensity: 0.6, pulseStrength: 0.6 }
    ]
};

function loadPreset(presetName) {
    blobs = presets[presetName].map(preset => ({ ...preset }));
    updateBlobsList();
}

animateBtn.addEventListener('click', () => {
    isAnimating = !isAnimating;
    animateBtn.textContent = isAnimating ? 'Stop Animation' : 'Start Animation';
    animateBtn.classList.toggle('active', isAnimating);
});

animSpeedSlider.addEventListener('input', () => {
    animSpeed = parseFloat(animSpeedSlider.value);
    animSpeedVal.textContent = animSpeed.toFixed(1);
});

flowStrengthSlider.addEventListener('input', () => {
    flowStrengthVal.textContent = flowStrengthSlider.value;
});

noiseStrengthSlider.addEventListener('input', () => {
    noiseStrengthVal.textContent = noiseStrengthSlider.value;
});

intensitySlider.addEventListener('input', () => {
    intensityVal.textContent = intensitySlider.value;
});

addBlobBtn.addEventListener('click', addBlob);

function drawMinimap() {
    const ctx = minimap.getContext('2d');
    ctx.clearRect(0, 0, minimap.width, minimap.height);
    ctx.strokeStyle = 'white';
    ctx.strokeRect(0, 0, minimap.width, minimap.height);
    
    blobs.forEach((blob, index) => {
        ctx.fillStyle = blob.color;
        ctx.beginPath();
        ctx.arc(blob.x * minimap.width, blob.y * minimap.height, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(index + 1, blob.x * minimap.width, blob.y * minimap.height - 8);
    });
}

minimap.addEventListener('mousedown', e => {
    const rect = minimap.getBoundingClientRect();
    const x = (e.clientX - rect.left) / minimap.width;
    const y = (e.clientY - rect.top) / minimap.height;
    
    let minDist = Infinity;
    let closestIndex = -1;
    blobs.forEach((blob, index) => {
        const dist = Math.hypot(x - blob.x, y - blob.y);
        if (dist < minDist && dist < 0.08) {
            minDist = dist;
            closestIndex = index;
        }
    });
    
    if (closestIndex !== -1) {
        dragState.active = true;
        dragState.blobIndex = closestIndex;
    }
});

window.addEventListener('mouseup', () => {
    dragState.active = false;
    dragState.blobIndex = -1;
});

minimap.addEventListener('mousemove', e => {
    if (!dragState.active || dragState.blobIndex === -1) return;
    
    const rect = minimap.getBoundingClientRect();
    const x = Math.min(Math.max((e.clientX - rect.left) / minimap.width, 0), 1);
    const y = Math.min(Math.max((e.clientY - rect.top) / minimap.height, 0), 1);
    
    blobs[dragState.blobIndex].x = x;
    blobs[dragState.blobIndex].y = y;
});

window.addEventListener('resize', () => {
    glcanvas.width = window.innerWidth;
    glcanvas.height = window.innerHeight;
    gl.viewport(0, 0, glcanvas.width, glcanvas.height);
});

updateBlobsList();

function render(t) {
    const time = t * 0.001 * animSpeed;
    
    gl.viewport(0, 0, glcanvas.width, glcanvas.height);
    gl.uniform2f(uniforms.resolution, glcanvas.width, glcanvas.height);
    gl.uniform1f(uniforms.time, time);
    gl.uniform1f(uniforms.flowStrength, parseFloat(flowStrengthSlider.value));
    gl.uniform1f(uniforms.noiseStrength, parseFloat(noiseStrengthSlider.value));
    gl.uniform1f(uniforms.intensity, parseFloat(intensitySlider.value));
    gl.uniform1i(uniforms.blendMode, parseInt(blendModeSelect.value));
    gl.uniform1i(uniforms.blobCount, blobs.length);
    
    const positions = [];
    const colors = [];
    const radii = [];
    const intensities = [];
    const pulseStrengths = [];
    
    blobs.forEach(blob => {
        positions.push(blob.x, blob.y);
        const rgb = hexToRgb(blob.color);
        colors.push(rgb[0], rgb[1], rgb[2]);
        radii.push(blob.radius);
        intensities.push(blob.intensity);
        pulseStrengths.push(blob.pulseStrength);
    });
    
    while (positions.length < 16) positions.push(0);
    while (colors.length < 24) colors.push(0);
    while (radii.length < 8) radii.push(0);
    while (intensities.length < 8) intensities.push(0);
    while (pulseStrengths.length < 8) pulseStrengths.push(0);
    
    gl.uniform2fv(uniforms.blobPositions, positions);
    gl.uniform3fv(uniforms.blobColors, colors);
    gl.uniform1fv(uniforms.blobRadii, radii);
    gl.uniform1fv(uniforms.blobIntensities, intensities);
    gl.uniform1fv(uniforms.blobPulseStrengths, pulseStrengths);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    drawMinimap();
    requestAnimationFrame(render);
}

window.removeBlob = removeBlob;
window.loadPreset = loadPreset;

requestAnimationFrame(render);
</script>
</body>
</html>
